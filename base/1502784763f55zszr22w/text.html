<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
<html><head><meta name="qrichtext" content="1" /><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><style type="text/css">
p, li { white-space: pre-wrap; }
</style></head><body style=" font-family:'DejaVu Sans'; font-size:11pt; font-weight:400; font-style:normal;">
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;">Регулярные выражения - это компактная форма записи представления о коллекции строк.</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />Регулярные выражения используются для:<br /><br />- проверки наличия фрагмента текста в строке<br />- поиска подстрок<br />- поиска и замены<br />- разбиения строк по точкам совпадения<br /><br />Самое простое регулярное выражение - это обычный символ, за которым может следовать квантификатор.<br /><br />Более сложные регулярные выражения могут состоять из любого числа выражений с квантификаторами <br />и могут включать проверки и дополнительные флаги.<br /><br />Простейшие регулярные выражения - это обычные литералы символов:<br /><br />a, b, c ... 1, 2, 3 ...<br /><br />Выражение:  11G <br />состоит из трех простейших регулярных выражений (литералов символов),<br />каждое из которых неявно определяет одно совпадение.<br /><br />Выражение 11G будет совпадать с одним символом 1<br />за которым следует один символ 1<br />за которым следует один символ G<br /><br />т.е. будет совпадать со строками:<br /><br />11G<br />ORACLE11GR2<br /><br /><br />В модуле re содержится функция re.search(r, s, f)<br />которая возвращает объект совпадения, <br />если совпадение с регулярным выражением r обнаруживается в любом месте строки s<br />(с учетом флагов f, если они заданы)<br />В противном случае возвращается None<br /><br /><br /><br />import re<br /><br />str = 'ORACLE11GR2'<br />match = re.search(r'11G', str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br /><br />&gt;&gt;&gt;found 11G<br /><br />Функция преобразует регулярное выражение во внутренний формат <br />- этот процесс называется компиляцией, а затем выполняет свою работу.<br /><br />  Это очень удобно для однократного применения регулярного выражения, <br />но если одно и то же регулярное выражение требуется применить несколько раз,<br />можно избежать излишних затратна компиляцию при каждом использовании,<br />скомпилировав выражение всего один раз с помощью функции:<br />re.compile(r, f)<br /><br /><br />import re<br /><br />c = re.compile(r'11G')<br />str = 'ORACLE11GR2'<br />match = re.search(c, str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br /><br />&gt;&gt;&gt;found 11G<br /><br /><br /><br />А лучше писать так:<br /><br />import re<br /><br />c = re.compile(r'11G')<br />str = 'ORACLE11GR2'<br />match = c.search(str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br />&gt;&gt;&gt;found 11G<br /><br /><br /><br />Большинство символов могут использоваться как литералы.<br /><br />Но некоторые из них имеют специальное значение в языке регулярных выражний:<br /><br /> \ . ^ $ ? + * { } [ ] ( ) |<br /><br />Чтобы их использовать как обычные символы (литералы) их нужно экранировать символом \<br /><br />\\  \.  \$ и т.д.<br /><br /><br />В пределах регулярных выражений можно также использовать большинство стандартных<br />экранированных последовательностей языка Python:<br /><br />\n - перевод строки<br />\t - символ табуляции<br /><br /> Экранированные последовательности с шестнадцатеричными кодами символов:<br /><br />\xHH<br />\uHHHH<br />\UHHHHHHHH<br /><br /><br /></span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">Символьный класс</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"> - это выражение состоящее из одного или нескольких символов заключенных в квадратные скобки.<br /><br />В отсутствии явного квантификатора соответствует точно одному символу, <br />который может быть любым символом из данного символьного класса.<br /><br />Регулярное выражение r[ea]d<br />совпадает с red или radar<br />но не со словом read<br /><br />Совпадение с единственной цифрой можно отыскать с помощью регулярного выражения:<br /><br />[0123456789]<br /><br />или в сокращенном виде:<br /><br />[0-9]<br /><br />Имеется возможность инвертировать значение символьного класса:<br /><br />[^0-9] <br /><br />соответствует любому не цифровому символу.<br /><br /><br />В символьном классе все </span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">специальные символы</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"> кроме \ , теряют свое специальное значение.<br />Но два символа  ^ и - в символьном классе приобретают новое значение:<br /><br />^ - если первый символ в классе, то инверсия.<br />- - если не первый символ в классе, то диапазон.<br /><br />Внутри символьных классов можно использовать следующие сокращенные формы записи:<br /><br />\d   - цифра   [0-9]<br />\D   - не цифра [^0-9]<br />\s   - пробельный символ [ \t\n\r\f\v]<br />\S   - не пробельный символ [^ \t\n\r\f\v]<br />\w   - символ слова [a-zA-Z0-9_]<br />\W   - символ не слова [^a-zA-Z0-9_]<br />.    - любой символ за исключением \n  (если флаг re.DOTALL то \n включается)<br /><br /><br />Например регулярное выражение:<br /><br />[\dA-Fa-f]<br />соответствует шестнадцатеричной цифре<br /><br />Символ точки за пределами символьного класса обозначает набор символов, <br />а внутри символьного класса сам символ точки.<br /><br /><br /></span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">Флаги</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;"> модуля регулярных выражений:</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />reobj = re.compile(&quot;regex pattern&quot;, re.VERBOSE | re.IGNORECASE | re.DOTALL | re.MULTILINE)<br />reobj = re.compile(r'(?aimsx)regex pattern')<br /><br /><br />Oracle11GR2<br />[Oo][Rr][Aa][Cc][Ll][Ee]11[Gg][Rr]2<br /><br />Игнорировать регистр в регулярном выражении можно так:<br />c = re.compile(r'11[Gg]')<br /><br />Но лучше использовать флаг:<br />c = re.compile(r'11g', re.IGNORECASE)<br />c = re.compile(r'(?i)11g')<br /><br /><br />mport re<br />c = re.compile(r'11g', re.IGNORECASE)<br />str = 'ORACLE11GR2'<br />match = c.search(str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br />&gt;&gt;&gt;found 11G<br /><br /><br /><br />import re<br />c = re.compile(r'(?i)11g')<br />str = 'ORACLE11GR2'<br />match = c.search(str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br />&gt;&gt;&gt;found 11G<br /><br /><br /><br /></span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;">Флаги</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />re.A<br />re.ASCII<br /><br />При наличии этого флага, проверки:<br />\b, \B, \s, \S, \w и \W<br />действуют так, как если бы они применялись к тексту,<br />содержащему только символы ASCII.<br />По умолчанию действие этих проверок основано на спецификации Юникода.<br /><br /><br />re.I<br />re.IGNORECASE<br /><br />Поиск совпадений выполняется без учета регистра символов.<br /><br /><br />re.M<br />re.MULTILINE<br /><br />При наличии этого флага, символ ^ соответствует началу текста и позиции сразу же после каждого перевода строки,<br />а символ $ соответствует позиции перед каждым символом перевода строки и концу текста.<br /><br /><br />re.S<br />re.DOTALL<br /><br />При наличии этого флага символ . соответствует любому символу, включая символ перевода строки.<br /><br /><br />re.X<br />re.VERBOSE<br /><br />Позволяет включать в регулярные выражения пробелы и комментарии.<br /><br /><br /><br /></span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;">Квантификаторы</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />Квантификаторы записываются в виде {m,n}<br />m - минимальное число совпадений с выражением<br />n - максимальное число совпадений с выражением<br /><br />Например <br /><br />e{1,1}e{1,1}     две e подряд ee<br /><br />или тоже самое <br /><br />e{2,2}<br /><br />Слову feel  они соответствуют, а слову felt нет.<br /><br />Сокращения.<br /><br />Если в квантификаторе указать одно число<br /><br />e{2}<br /><br />то оно означает и минимум и максимум<br /><br />т.е  e{2}  то же что и  e{2,2}<br /><br />Если квантификатор не указан, то предполагается что он равен единице {1,1}  или {1}<br /><br />Иногда удобно использовать различные минимальное и  максимальное значение:<br /><br />чтобы найти совпадение со словами <br /><br />travelled<br />traveled<br /><br />можно использовать выражение<br /><br />travel{1,2}ed<br />или<br />travell{0,1}ed<br /><br />Квантификатор {0,1}  имеет сокращение ? <br /><br />travell?ed<br /><br />Есть еще два сокращения для квантификаторов:<br /><br /></span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">+ - не менее одного  {1,n}<br />* - любое число      {0,n}</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />где n - означает максимально допустимое для квантификатора число, которое обычно не менее 32767<br /><br />Квантификатор + очень удобен.<br />Например, для поиска соответствий целым числам  можно было бы использовать выражение \d+<br />т.к. оно совпадает с одной или боее цифрами.<br /><br />В строке  4588.91 регулярное выражение \d+ найдет два совпадения: 4588 и 91<br /><br />С помощью belevel+ed  можно отыскать слова с одним или более символами l<br /><br />Например ошибки связанные с залипанием клавиш:<br /><br />beleveled<br />belevelled<br />belevellled<br /><br /><br />Квантификатор * используется реже - потому что он может приводить к получению неожиданных результатов.<br /><br />Например хотим найти все строки с комментариями  # <br /><br />#*     - так не годится<br /><br />Это выражение найдет и пустые строки (т.е. с нулевым совпадением)<br />Квантификаторы * и ? могут находить соответствие при нулевом числе совпадений.<br /><br />Если вы используете квантификатор * или ? , то обязательно убедитесь, что хотя бы одно подвыражение<br />в регулярном выражениииспользует ненулевой квантификатор (т.е. отличный от * и ?)<br /><br />Часто возможно заменить квантификатор * на ? и наоборот.<br /><br />tasselled<br /><br />Найти слово с одним или более символами l можно так:<br /><br />tassell*ed<br />или<br />tassel+ed<br /><br />а с двумя или более символами l можно так:<br /><br />tasselll*ed<br />или<br />tassell+ed<br /><br /><br />Регулярное выражение \d+ будет соответствовать строке 136<br />Почему оно соответствует всем цифрам, а не только первой?<br /><br />По умолчанию все квантификаторы являются жадными (или максимальными)<br />они стремятся соответствовать как можно большему числу символов.<br /><br />Любой квантификатор можно сделать нежадным (или минимальным), добавив после него символ ?.<br /><br />Знак вопроса имеет два разных значения:<br /><br />когда он употребляется самостоятельно, он интерпретируется как </span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">сокращенная форма записи квантификатора</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"> </span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">{0,1}</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />а когда он следует за квантификатором, он говорит о том, что стоящий перед ним квантификатор является </span><span style=" font-family:'FreeMono'; font-weight:600; color:#6a1009;">минимальным</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;">.<br /><br />Например выражение  \d+?<br /><br />обнаружит соответствие в строке 136 в трех местах:<br />1, 3 и 6<br /><br /><br />Ранее была представлена функция <br /><br />re.search(r,s,f)  <br /><br />которая находила и возвращала объект совпадения с регулярным выражением r в любом месте строки s<br /><br /><br />Существует более ограниченная функция<br /><br />re.match(r,s,f)<br /><br />которая находит и возвращает объект совпадения с регулярным выражением r только если он находится в начале строки s<br /><br /><br />Но существует и более продвинутая функция<br /><br />re.findall(r,s,f)<br /><br />которая находит и возвращает все непересекающиеся совпадения с регулярным выражением r в строке s.<br />Если регулярное выражение содержит сохраняющие группы, для каждого совпадения возвращается кортеж <br />с сохраненными фрагментами.<br /><br /><br />import re<br /><br />c = re.compile(r'11G')<br />str = 'ORACLE11GR2'<br />match = re.match(c, str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br /><br />&gt;&gt;did not find<br /><br /><br /><br /><br />import re<br /><br />c = re.compile(r'11G')<br />str = '11GR2'<br />match = re.match(c, str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br />&gt;&gt;found 11G<br /><br /><br /><br /><br />import re<br /><br />c = re.compile(r'11G')<br />str = 'ORACLE11GR2'<br />match = c.search(str)<br />if match:<br />    print('found', match.group())<br />else:<br />    print('did not find')<br /><br />&gt;&gt;&gt;found 11G<br /><br /><br /><br />С помощью функции  re.findall<br />можно увидеть разницу между жадным н не жадным квантификатором:<br /><br /><br />Жадный (максимальный):<br /><br />import re<br /><br />c = re.comьpile(r'\d+')<br />str = '0123456789'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['0123456789']<br /><br /><br />Не жадный (минимальный):<br /><br />import re<br /><br />c = re.compile(r'\d+?')<br />str = '0123456789'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']<br /><br /><br />Еще примеры с функцией  re.findall:<br /><br />Найдем все слова в строке, котрые начинаются на букву а (русский алфавит):<br /><br />import re<br /><br />c = re.compile(r'\bа[а-я]*')<br />str = 'электронный адрес angor@oracle.com, еще электронный адрес andrey@sun.com'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['адрес', 'адрес']<br /><br /><br />Тоже но теперь буква a (латинский алфавит):<br /><br />import re<br /><br />c = re.compile(r'\ba[a-z]*')<br />str = 'электронный адрес angor@oracle.com, еще электронный адрес andrey@sun.com'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['angor', 'andrey']<br /><br /><br />Найдем все электронные адреса в строке:<br /><br />import re<br /><br />c = re.compile(r'[\w\.-]+@[\w\.-]+')<br />str = 'электронный адрес angor@oracle.com, еще электронный адрес andrey@sun.com'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br /><br />&gt;&gt;['angor@oracle.com', 'andrey@sun.com']<br /><br /><br />Если регулярное выражение содержит сохраняющие группы, то их можно вывести в виде кортежа:<br /><br />import re<br /><br />c = re.compile(r'([\w\.-]+)@([\w\.-]+)')<br />str = 'электронный адрес angor@oracle.com, еще электронный адрес andrey@sun.com'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />for tuple in tuples:<br />    print(tuple[0])<br />    print(tuple[1])<br /><br /><br />&gt;&gt;[('angor', 'oracle.com'), ('andrey', 'sun.com')]<br /><br />&gt;&gt;angor<br />&gt;&gt;oracle.com<br />&gt;&gt;andrey<br />&gt;&gt;sun.com<br /><br /><br /></span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;">Квантификаторы регулярных выражений:</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />e?      Соответствует e{0,1}<br />        ноль или большее число вхождений выражения e <br />        по умолчанию жадный<br /><br /><br />e??     Соответствует e{0,1}?<br />        ноль или более число вхождений выражения e<br />        минимальный<br /><br /><br />e+      Соответствует e{1,}<br />        одно или более число вхождений выражения e<br />        по умолчанию жадный<br /><br /><br />e+?     Соответствует e{1,}? <br />        одно или более число вхождений выражения e<br />        минимальный<br /><br /><br />e*      Соответствует e{0,}<br />        ноль или более число вхождений выражения e<br />        по умолчанию жадный<br /><br /><br />e*?     Соответствует e{0,}?<br />        ноль или большее число вхождений выражения е<br />        минимальный<br /><br /><br />e{m}    Cоответствует точно m вхождениям выражения e<br /><br /><br />e{m,}   Соответствует по меньшей мере m вхождениям выражения e<br />        по умолчанию жадный<br /><br /><br />e{m,}?  Соответствует по меньшей мере m вхождениям выражения e<br />        минимальный<br /><br /><br />e{,n}   Соответствует не более чем n вхождениям выражения e<br />        по умолчанию жадный<br /><br /><br />e{,n}?  Соответствует не более чем n вхождениям выражения e<br />        минимальный<br />        <br />                        <br />e{m,n}  Соответствует не менее чем m и не более чем n вхождениям выражения e<br />        по умолчанию жадный<br />   <br /><br />e{m,n}? Соответствует не менее чем m и не более чем n вхождениям выражения e<br />        минимальный<br /><br /><br /><br /></span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;">Примеры сокращенных форм:</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br /><br />\d+  соответствует одной или более цифрам<br />     стремится соответствовать как можно большему числу символов<br /><br /><br />                                                 <br />\d+?  соответствует одной или более цифрам <br />      из последовательностей двух или более цифр будут найдены два или более вхождений по   одной цифре.<br /><br /><br />\d??  соответствует нулевому или большему числу цифр, но предпочтение будет отдано      нулевому числу совпадений.<br />      т.к. квантификатор минимальный<br />      он порождает ту же проблему что и *, и может находить соответствие с ничем,<br />      т.е. соответствовать любому тексту.<br /><br /><br /><br />Найдем в некотором файле все теги изображений<br /><br />Пример такого тега:<br /><br />&lt;IМG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt; <br /><br /><br /><br />import re<br /><br />c = re.compile(r'(?i)&lt;img.*&gt;')<br />str = '&lt;....  &lt;IМG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['&lt;IМG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;']<br /><br /><br />.*  означает ноль или более любых символов.<br />Жадный квантификатор захватил все символы &gt; и остановился на последнем символе &gt; в файле.<br />это не то что мы ожидали.<br /><br /><br />import re<br /><br />c = re.compile(r'(?i)&lt;img.*?&gt;')<br />str = '&lt;....  &lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['&lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;']<br /><br />или так:<br /><br /><br />import re<br /><br />c = re.compile(r'(?i)&lt;img[^&gt;]*&gt;')<br />str = '&lt;....  &lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['&lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;']<br /><br />или скомбинируем два предыдущих решения вместе:<br /><br />import re<br /><br />c = re.compile(r'(?i)&lt;img[^&gt;]*?&gt;')<br />str = '&lt;....  &lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['&lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;']<br /><br /><br />Во всех трех последних примерах на возвращается ожидаемая строка, казалось бы решение найдено.<br />Но если подумать то наши регулярные выражения найдут и такие строки:<br />&lt;img&gt;<br /><br />хотя такой тег является недопустимым и вряд ли появится в реальном html-коде, <br />но мы все же должны в своем регулярном выражении ориентироваться на допустимые строки<br /><br />Как известно, тег изображения должен иметь обязательный атрибут src.<br /><br />Напишем более точное регулярное выражение:<br /><br />&lt;img\s+[^&gt;]*?src=&quot;\w+[^&gt;]*?&gt;<br /><br />- подстрока  &lt;img<br /><br />- один или более пробельных символов<br /><br />- минимально ноль или более любых символов за исключением символа Ю<br />  (чтобы пропустить любые атрибуты, такие как alt)<br /><br />- строка src=&quot;<br /><br />- затем хотя бы один символ слова<br /><br />- затем любой (включая нулевое число) символ за исключением &gt; <br />  (чтобы пропустить любые другие атрибуты)<br /><br />- закрывающая угловая скобка<br /><br /><br />import re<br /><br />c = re.compile(r'(?i)&lt;img\s+[^&gt;]*?src=&quot;\w+[^&gt;]*?&gt;')<br />str = '&lt;....  &lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;   ...&gt;'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['&lt;IMG height=202 alt=&quot;Ленин в Смольном&quot; src=&quot;images/lenin-v-smolnom.jpg&quot; width=160 align=&quot;middle&quot; title=&quot;Ленин в Смольном.&quot;&gt;']</span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br />Регуряные выражения можно объединять через ИЛИ<br />тогда будет отыскиваться совпадение с любым альтернативным вариантом:<br /><br />import re<br /><br />c = re.compile(r'подпрограмма|алгоритм|подстрока')<br />str = 'подпрограмма алгоритм подстрока'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['подпрограмма', 'алгоритм', 'подстрока']<br /><br /><br /><br />Если мы применим операцию группировки (она же операция сохранения совпадения)<br />то то что не попало в сохранение не будет выведено функцией re.findall:<br /><br />import re<br /><br />c = re.compile(r'(подпрограмма|алгоритм)|подстрока')<br />str = 'подпрограмма алгоритм подстрока'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['подпрограмма', 'алгоритм', '']<br /><br /><br />Круглые скобки преследуют две цели:<br /><br />- сгруппирповать выражения<br />- сохранить текст, совпавший с выражением<br /><br />Например:<br /><br />подпрограмма|подстрока|алгоритм<br /><br />можно записать и так:<br /><br />под(программа|строка)|алгоритм<br /><br />Но во втором выражении будет побочный эффект сохранением выражений<br /><br />import re<br /><br />c = re.compile(r'под(программа|строка)|алгоритм')<br />str = 'подпрограмма алгоритм подстрока'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['программа', '', 'строка']<br /><br />Функция возвратила кортеж для сохранаемых групп.<br /><br /><br />Если мы  хотим избавится от такого побочного эффекта группировки<br />(хотим чтобы работала только группировка, но совпадения не сохранались)<br />то это можно сделать так:<br /><br />под(?:программа|строка)|алгоритм<br /><br />поставив вслед за открывающейся круглой скобкой символы  ?:<br /><br /><br />import re<br /><br />c = re.compile(r'под(?:программа|строка)|алгоритм')<br />str = 'подпрограмма алгоритм подстрока'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;['подпрограмма', 'алгоритм', 'подстрока']<br /><br /><br />А что будет если  написать так:<br /><br />(под(программа|строка)|алгоритм)<br /><br />тут будут сохранены два фрагмента, если будет обнаружено совпадение с первым выражением:<br /><br />подпрограмма или подстрока - первое сохранение<br />программа или строка       - второе сохранение<br /><br />и одно сохранение, если будет обнаружено совпадение со вторым выражением: <br /><br />алгоритм    - одно сохранение<br /><br /><br />import re<br /><br />c = re.compile(r'(под(программа|строка)|алгоритм)')<br />str = 'подпрограмма алгоритм подстрока'<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;[('подпрограмма', 'программа'), ('алгоритм', ''), ('подстрока', 'строка')]<br /><br /><br />Пусть некоторый файл состоит из строк вида:<br /><br />ключ = значение<br /><br />Ключ содержит только алфавитно-цифровые символы<br /><br />[a-zA-Z0-9_]   подойдет т.е. ключ соответствует регулярному выражению \w<br /><br /><br />Значение может содержать любые символы (кроме перевода строки)<br /><br />[^ \t\n\r\f\v]  любой непробельный символ \S не подойдет<br />т.к. наличие пробелов внутри значений допускается<br />поэтому выбираем  .+<br /><br /><br />Для каждой совпавшей строки выполним два сохранения:<br /><br />(\w) = (.+)<br /><br /><br />Например имеется пара:<br /><br /> предмет  =    квантовая механика<br /><br />Как видим начальные и конечные пробелы присутствуют и у ключа и у значения<br />кроме того, значение и внутри себя содержит пробел.<br /><br />Исключим из первого сохранения и начальные и конечные пробелы<br />а из второго пока только начальные<br /><br />для поиска пробельных символов символ \s ([ \t\n\r\f\v]) не годится<br />т.к. ему также соответствует символ перевода строки<br />для наших целей вполне подойдет следующий символьный класс [ \t]<br />(пробел и табуляция)<br /><br />[ \t]*(\w+)[ \t]*=[ \t]*(.+)<br /><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; background-color:#ffffff;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;">import re</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br />c = re.compile(r'[ \t]*(\w+)[ \t]*=[ \t]*(.+)')<br />str = ' предмет  =   квантовая механика     '<br />tuples = re.findall(c, str)<br />print(tuples)<br /><br />&gt;&gt;[('предмет', 'квантовая механика     ')]<br /><br /><br />Обратиться к захваченному тексту можно с помощью обратных ссылок<br />(ссылок на предшествующие группы)<br /><br /><br />\i <br /><br />где i - порядковый номер сохранающей группы<br />номер i начинается с 1<br /><br />Сохранение 0 выполняется автоматически, без применения круглых скобок<br />Оно хранит все соответствие, т.е. всю строку.<br /><br />(\w+)\s+\1<br /><br />Этому выражению соответствует слово, за которым следует по меньшей мере один пробельный символ<br />и затем тоже самое слово, что было захвачено в первой сохраненяющей группе.<br /><br />Иногда для ссылок на сохраняющие группы лучше использовать имена, а не порядковые номера.<br /><br />Именуются сохранения так:<br /><br />За открывающейся круглой скобкой указываем ?P&lt;name&gt;<br /><br />например<br /><br />(?P&lt;word&gt;\w+)<br /><br />а затем обращаемся к ней так:<br />                            <br />(?P=word)<br /><br />наш пример<br /><br />(\w+)\s+\1 <br /><br />можно переписать так:<br /><br />(?P&lt;word&gt;\w+)\s+(?P=word)<br /><br /><br /></span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000;">Проверки регулярных выражений.</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000;"><br /><br /></span></p>
<p style=" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;"><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;">^  -  соответствует началу текста.       с флагои re.MULTILINE соответствует позиции сразу после каждого символа перевода строки. $  -  соответствует концу текста.       с флагои re.MULTILINE соответствует позиции сразу перед каждыь символом перевода строки. \A  -  соответствует началу текста. \Z  -  соответствует концу текста. \b  -  соответствует границе слова (re.ASCII)        внутри символьных классов обозначает символ забоя (backspace) \B  -  соответствует границе не слова (re.ASCII) (?=e)    -  совпадение обнаруживается, усли текст справа от позиции проверки соответствует выражению e,              при этом изменения позиции поиска в тексте не происходит.             Эта проверка называется опережающей проверкой, или позитивной опережающей проверкой.             Например выражение:  \w+(?=\s+)             найдет слово, за которым стоит один или несколько пробельных символов. (?!e)    -  совпадение обнаруживается, если текст справа от позиции проверки не соответствует выражению e,              при этом изменения позиции поиска в тексте не происходит.             Эта проверка называется негативной опережающей проверкой. (?&lt;=e)   -  совпадение обнаруживается, если текст слева от позиции проверки соответствует выражению e,             эта проверка называется позитивной ретроспективной проверкой. (?&lt;!e)   -  совпадение обнаруживается, если текст слева от позиции проверки не соответствует выражению e,             эта проверка называется негативной ретроспективной проверкой. </span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000; background-color:#ffffff;">Рассмотрим чем отличаются проверки ^,$ и \A, \Z</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;"> Так совпадение обнаруживается: import re pattern = '''\Aabc de fgh$''' c = re.compile(pattern) line ='abc de fgh\n' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh А так не находит: import re pattern = '''\Aabc de fgh\Z''' c = re.compile(pattern) line ='abc de fgh\n' match = c.search(line) if match:     print(line, end=&quot;&quot;) Так тоже совпадение обнаруживается: import re pattern = '''abc de fgh''' c = re.compile(pattern) line ='abc de fgh\n' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh Так совпадение обнаруживается: import re pattern = '''abc\nde fgh''' c = re.compile(pattern) line ='abc\nde fgh' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh Так совпадение обнаруживается: import re pattern = '''abc\nde fgh$''' c = re.compile(pattern) line ='abc\nde fgh' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh И так совпадение обнаруживается: import re pattern = '''\Aabc\nde fgh$''' c = re.compile(pattern) line ='abc\nde fgh' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh И так совпадение обнаруживается: import re pattern = '''\Aabc\nde fgh\Z''' c = re.compile(pattern) line ='abc\nde fgh' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh Так совпадение обнаруживается: import re pattern = '''\Aabc\nde fgh$''' c = re.compile(pattern) line ='abc\nde fgh\n' match = c.search(line) if match:     print(line, end=&quot;&quot;) abc de fgh А так нет: import re pattern = '''\Aabc\nde fgh\Z''' c = re.compile(pattern) line ='abc\nde fgh\n' match = c.search(line) if match:     print(line, end=&quot;&quot;) В итоге получается что паттерн &quot;строка\Z&quot; совпадает со строкой &quot;строка&quot; и не совпадает со строкой &quot;строка\n&quot; Паттерн &quot;строка$&quot; совпадает и строкой &quot;строка&quot; и со строкой &quot;строка\n&quot; Паттерн &quot;строка&quot;  также совпадает и строкой &quot;строка&quot; и со строкой &quot;строка\n&quot; Паттерн &quot;строка&quot; совпадает и строкой &quot;строка&quot; и со строкой &quot;\nстрока\n&quot; но ни один из паттернов : &quot;^строка&quot; &quot;\Aстрока&quot; не совпадет со строкой: &quot;\nстрока&quot; </span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000; background-color:#ffffff;">Проверки \b и \B</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;"> Регулярное выражение jet будет находить в тексте: the jet and jetski are noisy несколько соответствий. Проверка \b - граница слова поможет избежать лишних нахождений. Выражение \bjet\b  будет находить только одно соответствие. import re c = re.compile(r'(jet)') str = 'the jet and jetski are noisy' tuples = re.findall(c, str) print(tuples) C:\projects&gt;python test1.py ['jet', 'jet'] import re c = re.compile(r'(\bjet\b)') str = 'the jet and jetski are noisy' tuples = re.findall(c, str) print(tuples) C:\projects&gt;python test1.py ['jet'] Выражение  \bg найдет соответствие в тексте: good   и тексте: a good    но не найдет соответствия в тексте: together Выражение \Bg не найдет соответствия в тексте: good  и тексте: a good    но найдет соответствие в тексте: together import re c = re.compile(r'(\bg)') str = 'together' tuples = re.findall(c, str) print(tuples) C:\projects&gt;python test1.py [] import re c = re.compile(r'(\Bg)') str = 'together' tuples = re.findall(c, str) print(tuples) C:\projects&gt;python test1.py ['g'] Выражение: aircraft|airplane|jet можно записать так: \baircraft\b|\bairplane\b|\bjetb\ или более просто: \b(?:aircraft|airplane|jet)\b т.е. граница слова, несохраняющее выражение, граница слова так как, выражения:  aircraft|airplane|jet \baircraft\b|\bairplane\b|\bjetb\ являются несохраняющими то и мы должны использовать несохраняющее выражение: \b(?:aircraft|airplane|jet)\b </span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000; background-color:#ffffff;">Опережающие проверки.</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;"> Пусть имеется текст: Helen Patricia Sharman Jim Sharman Sharman Joshi Helen Kelly нам необходимо отыскать текст Helen Patricia, но только если он относится к имени Sharman. Простейший способ такой: \b(Helen\s+Patricia)\s+Sharman\b Этому выражению будет соответствовать текст: Helen Patricia, только если он предшествует границе слова,  за которым следуют пробельные символы и слово Sharman и далее следует граница слова. Однако того же самого можно добиться с помощью опережающей проверки: \b(Helen\s+Patricia)(?=\s+Sharman\b) Чтобы сохранить определенное имя в самых разных его разновидностях: Helen Helen P. Helen Patricia можно задать такое регулярное выражение: \b(Helen(?:\s+(?:P\.|Patricia))?)\s+(?=Sharman\b) Обратите внимание, что сохранение выполняется только двумя синтаксическими конструкциями: (e) (?P&lt;name&gt;e) других форм сохраняющих группировок не существует. </span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; font-weight:600; color:#000000; background-color:#ffffff;">Ретроспективные проверки.</span><span style=" font-family:'Trebuchet MS,Trebuchet,Verdana,sans-serif'; color:#000000; background-color:#ffffff;"> Выражения, которые могут использоваться в ретроспективных проверках,  должны иметь фиксированную длину. Т.е. в них не могут использоваться квантификаторы ?, + и *. А интервальные квантификаторы должны задавать фиксированный размер: например {3}. Регулярное выражение [ \t]* найдет ноль или более символов пробелов и табуляций, т.к. квантификатор жадный,  то пока он не найдет их все (идущие друг за другом) он не остановится. Есть строка любых символов  (.+) Чтобы удалить из сохранения все пробелы, предшествующие данной строке (начальные пробелы) можно поступить так: [ \t]*(.+) Вспомнив, что  . (точка) - это любой символ за исключением перевода строки, перепишем это выражение так: [ \t]*([^\n]+) И еще вспомнив, что при наличии флага re.MULTILINE символ ^ соответствует началу текста и  позиции сразу же после каждого символа перевода строки, перепишем это выражение так: ^[ \t]*([^\n]+) Как же удалить конечные пробелы ? Например пусть имеется строка: aaabb  cde    fff    z          \t         \n Вся строка удовлетворяет условию регулярного выражения: ([^\n]+) Позиция проверки доходит до символа \n т.к. все символы, кроме \n,  удовлетворяют условию данного регулярного выражения. далее используем негативную обратную проверку:  (?&lt;![ \t]) ([^\n]+)(?&lt;![ \t]) негативная обратная проверка для совпадения требует, чтобы символы, предшествующие позиции проверки, не были пробелами или символами табуляции. Вследствии этого последний символ &quot;значения&quot; (в нашем случае это - z) сохраняется в сохраняющей группе,  а завершающие пробелы и символы табуляции - нет. import re c = re.compile(r'([^\n]+)(?&lt;![ \t])') str = 'aaabb  cde    fff    z          \t         \n' tuples = re.findall(c, str) print(tuples) C:\projects&gt;python test.py ['aaabb  cde    fff    z'] Вернемся к нашему регулярному выражению,  которое отыскивает пары ключ-значение: ^(\w+)=([^\n]+) Чтобы гарантировать, что каждая пара ключ=значение будет извлекаться из единственной строки и не будет происходить объединения нескольких строк необходимо установить флаг re.MULTILINE Если потребуется удалять начальные и конечные пробельные символы и использовать именованные  сохраняющие группы, то полное регулярное выражение могло бы выглядеть так: ^[ \t]*(?P&lt;key&gt;\w+)[ \t]*=[ \t]*(?P&lt;value&gt;[^\n]+)(?&lt;![ \t]) В регулярные выражения можно встраивать комментарии: (?# текст комментария) но на практике такие комментарии могут еще больше осложнить понимание. Лучшее решение заключается в использовании флага re.VERBOSE Он позволяет использовать внутри регулярных выражений пробельные символы  и обычные комментарии языка  Python с одним ограничением: - когда необходимо описать совпадение с пробельным символом, следует использовать  либо символ \s либо символьный класс, такой как []. Пример нашего регулярного выражения: ^[ \t]*                 # начало строки и необязательные начальные пробелы (?P&lt;key&gt;\w+)            # текст ключа [ \t]*=[ \t]*           # знак равенства с возможными пробелами, окружающими его (?P&lt;value&gt;[^\n]+)       # текст значения (?&lt;![ \t])              # негативная ретроспективная проверка для исключения завершающих пробелов. В контексте программирования на языке Python регулярные выражения, подобные этому,  обычно записываются в виде &quot;сырых&quot; строк, заключенных в тройные кавычки. Сырые строки используются чтобы избежать необходимости дублировать символы обратного слэша,  а тройные кавычки, чтобы записывать в нескольких строках. c = re.compile(r&quot;&quot;&quot;                ^[ \t]*                 # начало строки и необязательные начальные пробелы                (?P&lt;key&gt;\w+)            # текст ключа                [ \t]*=[ \t]*           # знак равенства с возможными пробелами, окружающими его                (?P&lt;value&gt;[^\n]+)       # текст значения                (?&lt;![ \t])              # негативная ретроспективная проверка для исключения завершающих пробелов.                &quot;&quot;&quot;, re.MULTILINE|re.VERBOSE) Ранее мы видели как можно получить доступ к сохраненному тексту внутри регулярного выражения: - по номеру группы - по имени группы (.....)(.....)(.....)\1    1      2      3 (?P&lt;name&gt;)(.....)(.....)(?P=name)       1       2      3 Однако имеется возможность принимать решение о наличии соответствия  в зависимости от наличия какого либо предыдущего совпадения: (.....)(.....)(.....)(?(2) expr1)    1      2      3 если было совпадение во втором сохранении то expr1 (.....)(.....)(.....)(?(2) expr1|expr2)    1      2      3 если было совпадение во втором сохранении то expr1, иначе expr2 Рассмотрим несколько вариантов записи атрибута src значения атрибута могут заключаться в апострофы, кавычки или без кавычек. src=&quot;girl.png&quot; src='girl.png' src=girl.png Как найти такой атрибут? src=([&quot;'])([^&quot;'&gt;]+)\1         1      2 Сохранение 1, сохраняет найденное совпадение содержащее либо кавычки либо апострофы. Сохранение 2, сохраняет найденное совпадение максимальной длины содержащее по крайней мере один символ, который не является кавычкой, апострофом или &quot;&gt;&quot;. Благодаря обратной ссылке \1, соответствие будет обнаружено, только если кавычки,  обрамляющие имя файла - одного типа. Какой тип кавычек вернет первое сохранение, таким должно и закрываться. Но это выражение не позволяет отыскивать имена файлов без кавычек. Чтобы устранить эту проблему, необходимо сделать символ открывающей кавычки необязательным,  а совпадение с закрывающей кавычкой выполнять, только если было найдено совпадение с открывающей кавычкой. src=([&quot;'])?([^&quot;'&gt;]+)(?(1)\1) Окончательный вид регулярного выражения &lt;img\s+                                       # начало текста [^&gt;]*?                                        # любые атрибуты предшествующие src src=                                                # начало атрибута src (?P&lt;quote&gt;[&quot;'])?            # необязательные открывающие кавычки (?P&lt;image&gt;[^&quot;'&gt;]+)     # имя файла изображения (?(quote)(?P=quote))                       # закрывающая кавычка, если была открывающая [^&gt;]*?                                         # любые атрибуты, следующие за src &gt;                                                 # конец тега Конечно существует более простая, но менее очевидная альтернатива: src=([&quot;']?)([^&quot;'&gt;]+)\1 Если имеется символ открывающей кавычки, он сохраняется в группе 1 Далее идут символы, следующие за открывающей кавычкой. Если открывающая кавычка отсутствовала, то по прежнему будет считаться,  что для группы 1 было найдено совпадение - совпадение с пустой строкой,  т.к. кавычка считается необязательной. (ее квантификатор означает ноль или более совпадений) В этом случае обратной ссылке также будет соответствовать пустая строка.</span></p></body></html>